namespace Labs.Lab8;

/*
Задача 6. Метро     https://acm.timus.ru/problem.aspx?space=1&num=1119&locale=ru
Ограничение по времени: 1 секунда
Ограничение по памяти: 64 мегабайта
    Многие программисты СКБ Контур любят добираться до работы на метро — благо,
    головной офис расположен совсем недалеко от станции Уралмаш. Ну а поскольку сидячий
    образ жизни требует активных физических нагрузок в свободное от работы время, многие
    сотрудники — в том числе и Никифор — ходят от дома до метро пешком.
    Никифор живёт в таком районе нашего города, где улицы образуют правильную
    сетку кварталов; все кварталы являются квадратами с длиной стороны, равной 100
    метрам. Вход на станцию метро расположен на одном из перекрёстков; Никифор начинает
    свой путь с другого перекрёстка, который расположен южнее и западнее входа в метро.
    Естественно, что выйдя из дома, Никифор всегда идет по улицам, ведущим либо на север,
    либо на восток. Некоторые кварталы, которые встречаются ему на пути, он может также
    пересечь по диагонали, ведущей из юго-западного угла квартала в северо-восточный.
    Таким образом, некоторые из маршрутов (ведущих всегда на север, восток или северо-
    восток), оказываются короче других. Никифора интересует, сколько времени понадобится
    ему на преодоление кратчайшего маршрута; для этого ему нужно знать его длину.
    Вы должны написать программу, которая по имеющейся информации о виде сетки
    кварталов рассчитывает длину кратчайшего маршрута из юго-западного угла в северовосточный.
Формат входных данных
    В первой строке находятся два целых числа N и M (0 < N, M ≤ 1000) — размер
    сетки кварталов с запада на восток и с юга на север соответственно. Никифор начинает
    путь с перекрёстка, который находится к юго-западу от квартала с координатами (1, 1);
    станция метро находится к северо-востоку от квартала с координатами (N, M). Во второй
    строке находится целое число K (0 ≤ K ≤ 100) — количество кварталов, через которые
    можно пройти наискось. Далее следуют K строк с парами целых положительных чисел,
    разделённых пробелами — координатами таких кварталов.
Формат выходных данных
    Требуется вывести длину кратчайшего пути от дома Никифора до станции метро в
    метрах, округлённую до целых метров.
*/

public static class Task6
{
    private const int INF = int.MaxValue;
    
    public static void Run()
    {
        var line1 = Console.ReadLine()!.Split();
        var N = int.Parse(line1[0]);
        var M = int.Parse(line1[1]);
        
        var line2 = Console.ReadLine()!.Split();
        var K = int.Parse(line2[0]);
        
        var diagonals = new HashSet<(int, int)>();
        for (var i = 0; i < K; i++)
        {
            var line = Console.ReadLine()!.Split();
            var x = int.Parse(line[0]);
            var y = int.Parse(line[1]);
            diagonals.Add((x, y));
        }
        
        var result = Solve(diagonals, N, M);
        
        Console.WriteLine(result);
    }

    private static int Solve(HashSet<(int, int)> diagonals, int N, int M)
    {
        var dist = new double[N + 1, M + 1];
        for (var i = 0; i <= N; i++)
            for (var j = 0; j <= M; j++)
                dist[i, j] = INF;
        
        dist[0, 0] = 0;
        var directions = new[]
        {
            (1, 0, 100), // east
            (0, 1, 100), // north
            (1, 1, 100 * Math.Sqrt(2)) // diagonal
        };

        var pq = new SortedSet<(double, int, int)> { (0, 0, 0) };

        while (pq.Count > 0)
        {
            var (currentDist, x, y) = pq.Min;
            pq.Remove(pq.Min);
            
            if (currentDist > dist[x, y]) continue;

            foreach (var (dx, dy, cost) in directions)
            {
                var nx = x + dx;
                var ny = y + dy;

                if (nx > N || ny > M) 
                    continue;
                
                var newDist = currentDist + cost;
                    
                if (dx == 1 && dy == 1 && !diagonals.Contains((nx, ny)))
                    continue;
                    
                if (newDist < dist[nx, ny])
                {
                    dist[nx, ny] = newDist;
                    pq.Add((newDist, nx, ny));
                }
            }
        }

        return (int)Math.Round(dist[N, M]);
    }
}